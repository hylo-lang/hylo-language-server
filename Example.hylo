trait Peekable {
  fun peek() -> Int
}

extension Int {
  fun peek() -> Int {
    return self
  }
}

given Int is Peekable {     
}

extension Int {
  fun squareRoot() -> Int {
    return self // todo
  }
}

fun concretePeek(value: Int) -> Int {
  return value.peek()
}

fun genericPeek<T is Peekable>(value: T) -> Int {
  return value.peek()
}

let z1: Int = 1.peek()
let z2: Int = (1 + 2).peek()

public struct Point {
  var x: Int
  var y: Int

  public init(_ x: Int, _ y: Int) {
    self.x = x
    self.y = y
  }

  public fun distance(to other: Point) -> Int {
    let dx = self.x - other.x
    let dy = self.y - other.y
    return (dx * dx + dy * dy).squareRoot()
  }

  public fun length() let -> Int {
    return (self.x * self.x + self.y * self.y).squareRoot()
  }
}

fun add(a a: Int, b b: Bool) -> Bool {
  return b
}

extension Int {
  fun prefix-() -> Int {
    return Int.zero() - self
  }

  fun infix!!(x: Int) -> Int {
    return self * 2
  }

  fun infix+++(x: Int) -> Int {
    return self * 3
  }
}

given w1: Bool is Peekable {
  fun peek() -> Int {
    if self { 1 } else { 0 }
  }
}

public fun main() {
  let x: Int = 42
  let y: Int = x + -x

  let p1 = Point(x: 3, y: 4)
  let p2 = Point.new(x: 0, y: 0)

  let s = p1.x * p1.x + p1.y * p1.y

  _ = add(a: 10, b: true)
  let a: A = (10, true)
  let b: A = (20, false)

  let _ = 10 +++ 32

  given w2: Bool is Peekable {
    fun peek() -> Int {
      if self { 1 } else { 0 }
    }
  }

  let k = true.peek()
}

type A = {Int, Bool}

